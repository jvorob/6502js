;VERSION HISTORY
;
; 0.1: 
;      Basic syntax working, some operations, numbers, .
;      The Great Escape
;
; 0.2:
;      Cleaned up post-escape
;
; 0.3:
;	   Compile mode works, colon works


;text input buffer
define buff $10
define max_buff_size $50
define buff_size $61
define buff_pos $62

;cursor position: pointer to top left pixel in vram
define curs_l $63
define curs_h $64
define heap_l $65
define heap_h $66

;pointer to character bitmap for character to be drawn
define D_BMP_L $e0
define D_BMP_H $e1

;generic data storage
define D_0 $e2
define D_1 $e3

define P0L $90
define P0H $91
define P1L $92
define P1H $93
define IR      $a0     ;word, instruction reg
define WA      $a2     ;word, word address (next word address?)
define CONTEXT $a4     ;word, location to search dict from
define CURRENT $a6     ;word, place to link entries to
define DP      $a8     ;word, next free dictionary space
define BASE    $aa     ;byte, current number base
define SP      $ab     ;byte, stack index
define RSP     $ac     ;byte, return stack index

;1st bit is first start
;2nd bit is underflow
;3rd(4) bit is mode (true=compile)
;4th(8) bit is state (true = immediate)
define MODE    $ad
define esc_char $5c



init:
  JMP forth_start


;;;;;;;;;;;;;;;
;; MAIN IO ROUTINES


get_line:
  JSR clear_buff
get_line_loop:
  JSR get_key
  CMP #esc_char
  BNE get_line_end
  JSR handle_escape
  JMP get_line_loop
get_line_end:
  JSR type_char
  JMP get_line_loop


handle_escape:
  JSR get_key
  CMP #$63
  BEQ he_c
  CMP #$64
  BEQ he_d
  CMP #$65
  BEQ he_e
  CMP #$68
  BEQ he_h
  CMP #$6a
  BEQ he_j
  CMP #$6b
  BEQ he_k
  CMP #$6c
  BEQ he_l
  CMP #$72
  BEQ he_r
  CMP #$73
  BEQ he_s
  RTS


;Handle \e ('enter' sequence)
;Discard the handle_escape return address,
;return directly to caller of get_line
he_e:
  PLA
  PLA
  RTS

he_h:
  BRK
  JSR he_s
  JSR reset_cursor
  LDA #<help_string
  STA P0L
  LDA #>help_string
  STA P0H
  LDA #$50
  JSR draw_string
  JSR get_key
  JSR he_l
  RTS

;Handle \d (backspace)
;Delete one character from the input buffer
he_d:
  LDX buff_pos
  BEQ he_d_end
  DEX
  STX buff_pos
  LDY #$00
  STY buff,X
  JSR cursor_back
  LDA #$20
  JSR clear_char
  he_d_end:
  RTS

;Handle \c (clear whole line)
he_c:
  JMP clear_entry

;Scroll up
he_j:
  LDA #1
  JSR scroll_up_all
  RTS

;??
he_k:
  RTS

;"Load screen" (experimental)
;For use with \s
he_l:
  JSR clear_screen
  LDA $0e
  STA $02
  LDA $0f
  STA $03
  LDA #buff
  STA $00
  LDA #0
  STA $01
  LDA #$50
  JSR strncpy
  STA buff_pos
  JSR he_r
  RTS

;Handle \r, (^l)
he_r:
  JSR redraw_buff
  RTS

;"Save screen" (experimental)
;For use with \l
he_s:
  LDA #0
  STA $01
  LDA #buff
  STA $00
  JSR strlen
  CLC
  ADC #1
  JSR malloc
  LDA #buff
  STA $02
  LDA #0
  STA $03
  LDA buff_size
  JSR strncpy
  LDA $01
  STA $0f
  LDA $00
  STA $0e
  LDA heap_l
  STA $00
  LDA heap_h
  STA $01
  LDY #04
  LDA ($00),Y
  STA $08
  INY
  LDA ($00),Y
  STA $09
  RTS


;Waits for a keypress, flashes the cursor in the interim
get_key:
  SEC
  JSR cursor_flash
poll_keys:
  LDA $ff                 ;new keypresses are placed into $00ff
  BNE poll_keys_continue 
  INY
  NOP
  NOP
  BNE poll_keys  ;Flash the cursor once every 256 pollings
  ROL            ;toggle the carry bit
  EOR #1
  LSR
  JSR cursor_flash ;draw/clear the cursor
  JMP poll_keys
poll_keys_continue:
  LDX #0
  STX $ff
  PHA
  JSR cursor_clear
  PLA
  RTS


cursor_clear:
  CLC
;draws the cursor if carry bit set
;clears cursor if carry bit clear
;preserves carry bit
cursor_flash:
  LDA curs_h
  STA $01
  LDA #$c0
  STA $00
  LDY curs_l
  LDX #5
  LDA #0
  ROL
cursor_flash_loop:
  STA ($00),Y
  INY
  DEX
  BNE cursor_flash_loop
  LSR
  RTS


;;;;;;;;;;;;;;;;;;;
;; SCREEN ROUTINES

;Lookup char bitmap from ascii code

;takes char code in A
;sets D_BMP_? to point to bitmap
lookup_key:
  SEC
  SBC #$20          ;bitmaps start with $20
  BPL lookup_key_1
  LDA #$20          ;< $20 becomes $20
lookup_key_1:
  CMP #50
  BCS lookup_key_p2
  LDX #>keytable1
  STX D_BMP_H
  BMI lookup_key_2  ;always
lookup_key_p2:
  LDX #>keytable2
  STX D_BMP_H
  SEC
  SBC #50
lookup_key_2: ;D_BMP_L = A*5
  STA D_BMP_L
  ASL A
  ASL A
  CLC
  ADC D_BMP_L
  STA D_BMP_L
  RTS


;Draws the ascii char in A
;at the current cursor position
;Preserves x, y
draw_char:
  STA D_1
  TXA
  PHA
  TYA
  PHA
  LDA D_1
  JSR lookup_key
  LDA curs_h
  CMP #$12
  BCS dc_end
  STA dc_l_c1+$02
  STA dc_l_c2+$02
  STA dc_l_c3+$02
  STA dc_l_c4+$02
  STA dc_l_c5+$02
  STA dc_l_c6+$02
  STA dc_l_c7+$02
  STA dc_l_c8+$02
  LDY #$00
  LDX curs_l
dc_loop_across:
  LDA (D_BMP_L),Y
  STA D_0
  CLC
  LDA #$80
  AND D_0
  BEQ dc_l_c1
  LDA #$01
  dc_l_c1:
  STA :$0000,X
  LDA #$40
  AND D_0
  BEQ dc_l_c2
  LDA #$01
  dc_l_c2:
  STA :$0020,X
  LDA #$20
  AND D_0
  BEQ dc_l_c3
  LDA #$01
  dc_l_c3:
  STA :$0040,X
  LDA #$10
  AND D_0
  BEQ dc_l_c4
  LDA #$01
  dc_l_c4:
  STA :$0060,X
  LDA #$08
  AND D_0
  BEQ dc_l_c5
  LDA #$01
  dc_l_c5:
  STA :$0080,X
  LDA #$04
  AND D_0
  BEQ dc_l_c6
  LDA #$01
  dc_l_c6:
  STA :$00a0,X
  LDA #$02
  AND D_0
  BEQ dc_l_c7
  LDA #$01
  dc_l_c7:
  STA :$00c0,X
  LDA #$01
  AND D_0
  BEQ dc_l_c8
  LDA #$01
  dc_l_c8:
  STA :$00e0,X
  INY
  INX
  CPY #$05
  BNE dc_loop_across
dc_end:
  PLA
  TAY
  PLA
  TAX
  RTS

;Clears the character under the cursor
clear_char:
  LDY #$04         ;start at the rightmost (5th) pixel
  CLC
cc_loop:           
  LDA #$00
  STA (curs_l),Y   ;clear 5 pixels
  DEY
  STA (curs_l),Y
  DEY
  STA (curs_l),Y
  DEY
  STA (curs_l),Y
  DEY
  STA (curs_l),Y
  TYA
  ADC #$24         ;move to the next row ($20), 5th pixel (+ $04)
  TAY
  BCC cc_loop
  RTS

;Clear the input buffer
clear_buff:
  LDA #0
  LDX #max_buff_size
cb_loop:
  DEX
  STA buff,X
  BNE cb_loop
  STA buff_pos
  RTS

;Clear the input buffer and the screen characters corresponding to it
clear_entry:
  LDX buff_pos
  BNE ce_loop
  RTS
ce_loop:
  LDA #0
  STA buff,X
  JSR cursor_back
  JSR clear_char
  DEX
  BNE ce_loop
  LDA #0
  STA buff_pos
  RTS

;;wipes the whole screen
clear_screen:
  CLC
  LDX #$02
  TXA
cs_loop:
  JSR clear_page
  INX
  TXA
  CMP #$12
  BNE cs_loop
cs_end:
  RTS

;clears one page of video memory
clear_page:
  STA cp_loop+$4
  STA cp_loop+$7
  STA cp_loop+$0a
  STA cp_loop+$0d
  STA cp_loop+$10
  STA cp_loop+$13
  STA cp_loop+$16
  STA cp_loop+$19
  STA cp_loop+$1c
  STA cp_loop+$1f
  STA cp_loop+$22
  STA cp_loop+$25
  STA cp_loop+$28
  STA cp_loop+$2b
  STA cp_loop+$2e
  STA cp_loop+$31
  LDY #$00
cp_loop:
  LDA #0
  STA :$0000,Y
  STA :$0001,Y
  STA :$0002,Y
  STA :$0003,Y
  STA :$0004,Y
  STA :$0005,Y
  STA :$0006,Y
  STA :$0007,Y
  STA :$0008,Y
  STA :$0009,Y
  STA :$000a,Y
  STA :$000b,Y
  STA :$000c,Y
  STA :$000d,Y
  STA :$000e,Y
  STA :$000f,Y
  TYA
  ADC #$10
  TAY
  BNE cp_loop
  RTS

scroll_up_all:
  ASL
  STA D_0
  LDA #$10
  SEC
  SBC D_0
  ADC #1
  STA D_1
  LDA #$2
scroll_up_all_1:
  PHA
  JSR scroll_up
  PLA
  CLC
  ADC #$02
  CMP D_1
  BNE scroll_up_all_1
  CLC
scroll_up_all_2:
  CMP #$12
  BEQ scroll_up_all_end
  PHA
  JSR clear_page
  PLA
  CLC
  ADC #$1
  BNE scroll_up_all_2
scroll_up_all_end:
  RTS


scroll_up:
  AND #$fe
  CLC
  TAX
su_prepare_pages:
  TXA
  STA su_loop+$5
  STA su_loop+$b
  STA su_loop+$11
  STA su_loop+$17
  STA su_loop+$1d
  STA su_loop+$23
  STA su_loop+$29
  STA su_loop+$2f
  ADC D_0
  STA su_loop+$2
  STA su_loop+$8
  STA su_loop+$e
  STA su_loop+$14
  STA su_loop+$1a
  STA su_loop+$20
  STA su_loop+$26
  STA su_loop+$2c
  LDY #$00
su_loop:
  LDA :$0000,Y
  STA :$0000,Y
  LDA :$0001,Y
  STA :$0001,Y
  LDA :$0002,Y
  STA :$0002,Y
  LDA :$0003,Y
  STA :$0003,Y
  LDA :$0004,Y
  STA :$0004,Y
  LDA :$0005,Y
  STA :$0005,Y
  LDA :$0006,Y
  STA :$0006,Y
  LDA :$0007,Y
  STA :$0007,Y
  TYA
  ADC #$08
  TAY
  BNE su_loop
  TXA
  ADC #0
  TAX
  AND #$01
  BEQ su_end
  JMP su_prepare_pages
su_end:
  RTS

;Tries to type the character in reg A
;(adds to buff, draws it, advances cursor)
;returns if buffer full
;newlines if necessary
type_char:
  STA $00
  LDA buff_pos
  CMP buff_size
  BNE type_char_1
  RTS
type_char_1:
  LDA $00
  LDX buff_pos
  STA buff,X
  INC buff_pos
  LDA curs_h
  CMP #$12
  BCC type_char_2
  JSR newline
type_char_2:
  LDA $00
  JSR draw_char
  JSR cursor_fwd
  RTS


redraw_buff:
  JSR reset_cursor
  LDA #buff
  STA P0L
  LDA #0
  STA P0H
  LDA buff_size
  JSR draw_string
  RTS

;prints a null-terminated string at current cursor position
draw_string:
  LDY #0
  TAX
  BEQ draw_string_end
draw_string_loop:
  LDA (P0L),Y
  BEQ draw_string_end
  JSR draw_char
  JSR cursor_fwd
  INY
  DEX
  BNE draw_string_loop
draw_string_end:
  TYA
  RTS


reset_cursor:
  PHA
  LDA #$02
  STA curs_l
  STA curs_h
  PLA
  RTS

cursor_fwd:
  LDA curs_h
  CMP #$12
  BCS cursor_fwd_end
  LDA curs_l
  CLC
  ADC #$06
  CMP #27
  BMI cursor_fwd_2
  LDA curs_h
  ADC #0
  STA curs_h
  AND #$01
  EOR #$01
  ASL A
cursor_fwd_2:
  STA curs_l
cursor_fwd_end:
  RTS

cursor_back:
  LDA curs_l
  SEC
  SBC #$06
  BPL cursor_back_skip
  LDA #25
  DEC curs_h
  LDA curs_h
  AND #$01
  EOR #$01
  ASL A
  CLC
  ADC #$18
cursor_back_skip:
  STA curs_l
  RTS


freshline:
  LDA curs_l
  CMP #2
  BNE newline
  RTS

newline:
  LDA #$02
  STA curs_l
  CLC
  ADC curs_h
  AND #$fe
  CMP #$12
  BMI newline_1
  LDA #2
  JSR scroll_up_all
  LDA #$e ;was $a
newline_1:
  STA curs_h
  RTS



;;;;;;;;;;;;;;;;;;;
; END SCREEN ROUTINES


;;;;;;;;;;;;;;;;;;;
;; HEAP ROUTINES

reset_heap:
  LDA #$b0
  STA heap_h
  LDA #$00
  STA heap_l
  LDA #0
  STA $b000
  LDA #0
  STA $b001
  LDA #heap_l
  STA $b002
  LDA #0
  STA $b003
  LDA #0
  STA $b004
  LDA #$20
  STA $b005
  RTS

malloc:
  TAX
  INX
  TXA
  CMP #$06
  BCS mal2
  LDA #$06
mal2:
  STA $02
  LDA heap_l
  STA $00
  LDA heap_h
  STA $01
  LDX #$00
mal_wlk_loop:
  LDY #$04
  LDA ($00),Y
  CMP $02
  BCS mal_split2
  INY
  LDA ($00),Y
  BNE mal_split
  JSR walk_fwd
  JMP mal_wlk_loop
mal_split:
  DEY
  LDA ($00),Y
mal_split2:
  SEC
  SBC $02
  STA ($00),Y
  PHA
  INY
  BCS mal_split3
  LDA ($00),Y
  SBC #0
  STA ($00),Y
mal_split3:
  PLA
  CLC
  ADC $00
  PHA
  LDA ($00),Y
  ADC $01
  STA $01
  PLA
  STA $00
  DEC $02
  LDA $02
  STA ($00,X)
  INC $00
  BNE mal_split4
  INC $01
mal_split4:
  RTS

walk_fwd:
  PHA
  LDA ($00,X)
  PHA
  INC $00,X
  BNE wf2
  INC $01,X
wf2:
  LDA ($00,X)
  BEQ end
  STA $01,X
  PLA
  STA $00,X
  PLA
  RTS

;;;;;;;;;;;;;;;;
;; Misc Helper routines

strncpy:
  TAX
  BEQ strncpy_end
  LDY #0
strncpy_loop:
  LDA ($02),Y
  STA ($00),Y
  BEQ strncpy_end
  INY
  DEX
  BNE strncpy_loop
  BEQ strncpy_end
strncpy_end:
  TYA
  RTS

strlen:
  LDY #0
strlen_loop:
  LDA ($00),Y
  BEQ strlen_end
  INY
  BNE strlen_loop
  JMP end
strlen_end:
  TYA
  RTS

end:
  LDA #$CD
  TAX
  TXS
  PLA
  TAX
  PLA
  TAY
  LDA #$AB
end2:
  JMP end2
  JMP $feeb
  NOP
  NOP
  NOP


help_string:
  DCB "Help:     \d bkspc  \c clrscrn\h help   \s savscrn\l ld scrn"
  DCB $00

make_uppercase:
  CMP #$7b
  BPL mu_end
  CMP #$61
  BMI mu_end
  SBC #$20
mu_end:
  RTS

zero_cmp:
  LDX #0
  STX $02
  STX $03
  BEQ stack_cmp_1
stack_cmp:
  LDX #2
  JSR popDS
  LDX #0
stack_cmp_1:
  JSR popDS
  LDA $01
  CMP $03
  BNE stack_cmp_end
  LDA $00
  CMP $02
stack_cmp_end:
  PHP
  LDA $01
  EOR $03
  AND #$80
  BEQ stack_cmp_end_2
  LDA #1
  TSX
  EOR $101,X
  STA $101,X
stack_cmp_end_2:
  PLP
  RTS

_two_comp:
  LDA $01,X
  EOR #$ff
  STA $01
  LDA $00,X
  EOR #$ff
  CLC
  ADC #1
  STA $00,X
  BNE _two_comp_end
  INC $01,X
_two_comp_end:
  RTS

divide:
  LDX #0
  STX $03
  STX $04
  STX $05
  STX $06
  LDY #$10
  LDA $01
  BMI divide_loop
divide_zero_loop:
  DEY
  BEQ divide_loop
  ASL $00
  ROL $01
  BPL divide_zero_loop
divide_loop:
  ASL $00
  ROL $01
  LDA $05
  ROL
  STA $05
  SEC
  SBC $02
  BCC divide_rem_skip
  STA $05
divide_rem_skip:
  ROL $03
  ROL $04
  DEY
  BNE divide_loop
  RTS

multiply:
  LDA $00
  STA $02
  LDA $01
  STA $03
  LDA $04
  LDX #$08
  LDA $04
multiply_zero_loop:
  ASL
  BCS multiply_dbl
  DEX
  BCC multiply_zero_loop
  BEQ multiply_end
multiply_loop:
  ASL
  BCC multiply_dbl
  STA $04
  CLC
  LDA $00
  ADC $02
  STA $00
  LDA $01
  ADC $03
  STA $01
  LDA $04
multiply_dbl:
  DEX
  BEQ multiply_end
  ASL $00
  ROL $01
  BCC multiply_loop
multiply_end:
  RTS

;Pops data stack into (X)
popDS:
  LDY SP
  BNE popDS_notunderflow
  LDA MODE
  ORA #$02
  STA MODE   ;set 2 bit (underflow)
popDS_notunderflow:
  LDA DSTACK,Y
  STA $00,X
  INY
  LDA DSTACK,Y
  STA $01,X
  INY
  STY SP
  RTS

popRS:
  LDY RSP
  LDA RSTACK,Y
  STA $00,X
  INY
  LDA RSTACK,Y
  STA $01,X
  INY
  STY RSP
  RTS

pushByte:
  LDY SP
  DEY
  DEY
  STA DSTACK,Y
  LDA #0
  STA DSTACK+1,Y
  STY SP
  RTS

pushDS:
  LDY SP
  DEY
  LDA $01,X
  STA DSTACK,Y
  DEY
  LDA $00,X
  STA DSTACK,Y
  STY SP
  RTS

pushRS:
  LDY RSP
  DEY
  LDA $01,X
  STA RSTACK,Y
  DEY
  LDA $00,X
  STA RSTACK,Y
  STY RSP
  RTS

fetch:
  LDA ($00,X)
  PHA
  INC $00,X
  LDA ($00,X)
  STA $00,X
  PLA
  STA $00,X
  RTS


;Conditional jump forward
_if:
  DCB :_if+$2
  LDX #0
  JSR popDS
  LDA $00
  ORA $01
  BEQ _else+$2  ;if false jump forward
  INC IR
  BEQ _if_incirh
  JMP next
_if_incirh:
  INC IR+1
  JMP next

;jumps forward specified number of bytes 
;must be at least 1 to skip over itself
_else:
  DCB :_else+$2
  LDX #0
  LDA (IR,X)
  CLC
  ADC IR
  STA IR
  BCS _if_incirh
  JMP next


;conditional jump back
_end:
  DCB :_end+$2
  LDX #0
  JSR popDS
  LDA $00
  ORA $01
  BEQ _while+$2 ;jump back
  INC IR
  BEQ _if_incirh
  JMP next

;unconditional jump back
;must be at least 2 to skip back over _while instruction
_while:
  DCB :_while+$2
  LDA IR
  SEC
  LDX #0
  SBC (IR,X)
  STA IR
  BCC _while_decirh
  JMP next
_while_decirh:
  DEC IR+1
  JMP next

_litnum:
  DCB :_litnum+$2
  LDY #1
  LDA (IR),Y
  STA $01
  DEY
  LDA (IR),Y
  STA $00
  LDX #0
  JSR pushDS
  LDA IR
  CLC
  ADC #2
  STA IR
  BCS _if_incirh
  JMP next

_clitnum:
  DCB :_clitnum+$2
  LDX #0
  STX $01
  LDA (IR,X)
  STA $00
  JSR pushDS
  INC IR
  BEQ _if_incirh
  JMP next

;pop an address, restart execution there
_patch:
  DCB :_patch+$2
  LDX #WA
  JSR popDS
  JMP forth_start

;pushes compile mode to stack
_compile_p:
  DCB :_compile_p+$2
  LDX #0
  STX $00
  STX $01
  LDA #$4  ;bit 3
  BIT MODE
  BEQ _compile_p_2
  LDA #1
  STA $00
_compile_p_2:
  JSR pushDS
  JMP next


*=$d000
startmsg:
  DCB $0a
  DCB "FORSH 0.3:"

restartmsg:
  DCB $08
  DCB "RESHTART"

stackmsg:
  DCB $0a
  DCB "STK UNDRFL"

okmsg:
  DCB $03
  DCB " OK"


;;;;;;;;
; Outer interpeter
; Gets input
; See if it's a command (if so, execute it)
; See if it's a number
; 
outer_interp:
  DCB :type_1          ;printmessage()
  DCB :inline_1        ;readinput()
  DCB :aspace_1        ;token:
  DCB :token_1         ;gettoken(' ');
  DCB :qsearch_1       ;qsearch()
  DCB :_if,$0e         ;if(!found) {
  DCB :qnumber_1       ;    qnumber()
  DCB :_if,  $06       ;    if(!parsednumber) {
  DCB :question_1      ;       question()
  DCB :_while,$16      ;         goto inline;
  DCB :_while,$15      ;    } else goto token;
  DCB :qexecute_1       ;} else { execute()
  DCB :qstack_1        ;  check stack
  DCB :_while,$1c      ;  goto token}


;;;;;;;;;;;;;;;;;;;;
;;;;Inner interpreter

;;Relevant stuff
;WA: word address of instruction being executed, fetched from IR
;(that is, the code/definition of that instruction)
;IR: current instruction being executed, stepped by +2 each time
;(i.e. position in its parent routine's code/definition)
;Return Stack (RS), jumped back to on semicolon


;Descend into executing a forth word
colon:
  ;Push the IR to the return stack
  LDY RSP
  DEY
  LDA IR+1
  STA RSTACK,Y
  DEY
  LDA IR
  STA RSTACK,Y
  STY RSP

  ;Forth-jump into the word
  LDA WA
  STA IR
  LDA WA+1
  STA IR+1
  JMP next

;Return from executing a forth word
semi:
  DCB :semi+$2
  ;Pop return stack into IR
  LDY RSP
  LDA RSTACK,Y
  STA IR
  INY
  LDA RSTACK,Y
  STA IR+1
  INY
  STY RSP
next:
  CLC
  ;*WA = *IR
  LDY #0
  LDA (IR),Y
  STA WA
  INY
  LDA (IR),Y
  STA WA+1
  ;IR++
  LDA IR
  ADC #$02
  STA IR
  BCC run
  INC IR+1
  CLC
run:
  ;Jump to contents of WA
  ;i.e.: WA = 1111, *1111 = 2222, jmp 2222
  ;Also, WA += 2, so that colon, can just jump into the new WA
  LDA WA+1
  STA run_1+$2
  LDA WA
  STA run_1+$1
  ADC #$02
  STA WA
  BCC run_1
  INC WA+1
run_1:
  JMP ($0000)


;starts with word address on the stack
;executes if state=mode
;otherwise stores in dict
;(if compiliing, will only execute compile words, and will store others)
;then checks stack?
qexecute_1:
DCB :colon
  DCB :mode_var_1
  DCB :cat_1
  DCB :dup_1
  DCB :dup_1        ;stack is WA M M M<
  DCB :_clitnum, $4 ;mode bit
  DCB :and_1
  DCB :not_1
  DCB :swap_1
  DCB :_clitnum, $8 ;state bit
  DCB :and_1        ;stack is now WA, M, ModeF, StateF<
  DCB :not_1
  DCB :eq_1         ;are the modes equal
  DCB :swap_1       ;stack :WA, SeqM, M<

      ;clear state bit
  DCB :_clitnum,$f7 ;SeqM, M, ~bit4
  DCB :and_1
  DCB :mode_var_1
  DCB :cbang_1      

  DCB :_if,$6      ;if(STATE == MODE)
  DCB :execute_1    ;  execute();
  DCB :_else,$3     ;else
  DCB :comma_1      ;  enclose();
  DCB :semi

;First searches context
;Then searches compile (setting state if found)
;returns wa 
qsearch_1:
DCB :colon
  DCB :context_var_1
  DCB :at_1
  DCB :search_1          ;search context
  DCB :_if,$27           ;search compile, else jump to clitnum,0
	DCB :_compile_p
	DCB :_if,$1d            ;if compile mode, search compile, else return 1
	  DCB :compiler_var_1
	  DCB :at_1
	  DCB :search_1
	  DCB :_if,$4           ;if still not found return 1 (false)
	  DCB :_else,$11        
	  DCB :mode_var_1       ;else set state bit
	  DCB :cat_1
	  DCB :_clitnum,$8      ;set bit 4 (8)
	  DCB :or_1
	  DCB :mode_var_1
	  DCB :cbang_1          ;finished setting
	  DCB :_else,$6          ;return 0 (jump to clitnum-0)
						  ;else:
	  DCB :_clitnum, 1      ;return 1
	  DCB :semi
  DCB :_clitnum,0
  DCB :semi



last_compile:
semicolon: ;(compile word)
DCB $1
DCB ";~~~~"
DCB :0
semicolon_1:
DCB :colon
  DCB :_litnum, :semi
  DCB :comma_1        ;enclose semi
  DCB :mode_var_1     ;clear compile mode
  DCB :cat_1
  DCB :_clitnum, $fb  ;$ff - 4 (3rd bit is mode) 
  DCB :and_1
  DCB :mode_var_1
  DCB :cbang_1        ;finished clearing
  DCB :current_var_1  ;update context
  DCB :at_1
  DCB :context_var_1
  DCB :bang_1         ;finished updating
  DCB :semi

;Execute the word 
execute:
DCB $07
DCB "EXECU"
DCB :0
execute_1:
DCB :execute_1+$2
  LDX #WA
  JSR popDS
  CLC
  JMP run


;Push to RS
r_left:
DCB $2
DCB "<R~~~"
DCB :execute
r_left_1:
DCB :r_left_1+$2
  LDX #0
  JSR popDS
  JSR pushRS
  JMP next


;Pop from RS
r_right:
DCB $2
DCB "R>~~~"
DCB :r_left
r_right_1:
DCB :r_right_1+$2
  LDX #0
  JSR popRS
  JSR pushDS
  JMP next


over:
DCB $04
DCB "OVER~"
DCB :r_right
over_1:
DCB :over_1+$2
  LDY SP
  INY
  INY
  LDA DSTACK,Y
  STA $00
  LDA DSTACK+1,Y
  STA $01
  LDX #0
  JSR pushDS
  JMP next


drop:
DCB $04
DCB "DROP~"
DCB :over
drop_1:
DCB :drop_1+$2
  LDX #0
  JSR popDS
  JMP next

dup:
DCB $03
DCB "DUP~~"
DCB :drop
dup_1:
DCB :dup_1+$2
  LDX #0
  JSR popDS
  JSR pushDS
  JSR pushDS
  JMP next

;rrot if top of stack on right
rrot:
DCB $04
DCB "RROT~"
DCB :dup
rrot_1:
DCB :rrot_1+$2
  LDY SP
  TYA
  CLC
  ADC #$04
  TAX
  LDA DSTACK,X   ;bottom
  STA $00        ;->temp
  LDA DSTACK+1,X
  STA $01
  LDA DSTACK,Y   ;top
  STA DSTACK,X   ;->bottom
  LDA DSTACK+1,Y
  STA DSTACK+1,X
  DEX
  DEX
  LDA DSTACK,X  ;mid
  STA DSTACK,Y  ;->top
  LDA DSTACK+1,X
  STA DSTACK+1,Y
  LDA $00       ;temp
  STA DSTACK,X  ;->mid
  LDA $01
  STA DSTACK+1,X
  JMP next

;lrot if top of stack on right
lrot:
DCB $04
DCB "LROT~"
DCB :rrot
lrot_1:
DCB :lrot_1+$2
  LDX SP
  LDA DSTACK,X
  STA $00
  LDA DSTACK+1,X
  STA $01
  TXA
  CLC
  ADC #$04
  TAY
  LDA DSTACK,Y
  STA DSTACK,X
  LDA DSTACK+1,Y
  STA DSTACK+1,X
  INX
  INX
  LDA DSTACK,X
  STA DSTACK,Y
  LDA DSTACK+1,X
  STA DSTACK+1,Y
  LDA $00
  STA DSTACK,X
  LDA $01
  STA DSTACK+1,X
  JMP next

swap:
DCB $04
DCB "SWAP~"
DCB :lrot
swap_1:
DCB :swap_1+$2
  LDX #0
  JSR popDS
  LDX #2
  JSR popDS
  LDX #0
  JSR pushDS
  LDX #2
  JSR pushDS
  JMP next

;logical and
land:
DCB $04
DCB "LAND~"
DCB :swap
land_1:
DCB :land_1+$2
  LDX #0
  JSR popDS
  LDY SP
  LDA $00
  ORA $00
  BEQ land_f
  LDA DSTACK,Y
  ORA DSTACK+1,Y
  BEQ land_f
  LDA #1          ;true
  STA DSTACK,Y
  LDA #0
  STA DSTACK+1,Y
  JMP next
land_f:           ;false
  LDA #0
  STA DSTACK,Y
  STA DSTACK+1,Y
  JMP next


;logical or
lor:
DCB $03
DCB "LOR~~"
DCB :land
lor_1:
DCB :lor_1+$2
  LDX #0
  JSR popDS
  LDY SP
  LDA $00
  ORA $00
  ORA DSTACK,Y
  ORA DSTACK+1,Y
  BEQ lor_f
  LDA #1         ;true
  STA DSTACK,Y
  LDA #0
  STA DSTACK+1,Y
  JMP next
lor_f:           ;false
  LDA #0
  STA DSTACK,Y
  STA DSTACK+1,Y
  JMP next

;bitwise and
and:
DCB $03
DCB "AND~~"
DCB :lor
and_1:
DCB :and_1+$2
  LDX #0
  JSR popDS
  LDY SP
  LDA $00
  AND DSTACK,Y
  STA DSTACK,Y
  LDA $01
  AND DSTACK+1,Y
  STA DSTACK+1,Y
  JMP next

;bitwise or
or:
DCB $02
DCB "OR~~~"
DCB :and
or_1:
DCB :or_1+$2
  LDX #0
  JSR popDS
  LDY SP
  LDA $00
  ORA DSTACK,Y
  STA DSTACK,Y
  LDA $01
  ORA DSTACK+1,Y
  STA DSTACK+1,Y
  JMP next

;bitwise xor
xor:
DCB $03
DCB "XOR~~"
DCB :or
xor_1:
DCB :xor_1+$2
  LDX #0
  JSR popDS
  LDY SP
  LDA $00
  EOR DSTACK,Y
  STA DSTACK,Y
  LDA $01
  EOR DSTACK+1,Y
  STA DSTACK+1,Y
  JMP next

;logical not
not:
DCB $03
DCB "NOT~~"
DCB :xor
not_1:
DCB :not_1+$2
  LDX #0
  JSR popDS
  LDA $00
  ORA $01
  BEQ not_f
  LDA #0
  BEQ not_end
not_f:
  LDA #1
not_end:
  STA $00
  STX $01
  JSR pushDS
  JMP next

modslash:
DCB $04
DCB "MOD/~"
DCB :not
modslash_1:
DCB :modslash_1+$2
  LDX #2
  JSR popDS
  LDX #0
  JSR popDS
  JSR divide
  LDX #$03
  JSR pushDS
  LDX #$05
  JSR pushDS
  JMP next

slash:
DCB $01
DCB "/~~~~"
DCB :modslash
slash_1:
DCB :slash_1+$2
  LDX #2
  JSR popDS
  LDX #0
  JSR popDS
  JSR divide
  LDX #$03
  JSR pushDS
  JMP next

star:
DCB $01
DCB "*~~~~"
DCB :slash
star_1:
DCB :star_1+$2
  LDX #4
  JSR popDS
  LDX #0
  JSR popDS
  JSR multiply
  LDX #0
  JSR pushDS
  JMP next

;stores stack(2) at stack(1)
;2 bytes, little endian bytes
bang:
DCB $01
DCB "!~~~~"
DCB :star
bang_1:
DCB :bang_1+$2
  LDX #2
  JSR popDS
  LDX #0
  JSR popDS
  LDA $00
  LDY #0
  STA ($02),Y
  INY 
  LDA $01
  STA ($02),Y
  JMP next

cbang:
DCB $02
DCB "C!~~~"
DCB :bang
cbang_1:
DCB :cbang_1+$2
  LDX #2
  JSR popDS
  LDX #0
  JSR popDS
  LDA $00
  STA ($02,X)
  JMP next

at:
DCB $01
DCB "@~~~~"
DCB :cbang
at_1:
DCB :at_1+$2
  LDX SP
  LDA DSTACK,X
  STA $00
  LDA DSTACK+1,X
  STA $01
  LDY #0
  LDA ($00),Y
  STA DSTACK,X
  INY
  LDA ($00),Y
  STA DSTACK+1,X
  JMP next

cat:
DCB $02
DCB "C@~~~"
DCB :at
cat_1:
DCB :cat_1+$2
  LDX SP
  LDA DSTACK,X
  STA $00
  LDA DSTACK+1,X
  STA $01
  LDA #0
  STA DSTACK+1,X
  TAY
  LDA ($00),Y
  STA DSTACK,X
  JMP next

plus:
DCB $01
DCB "+~~~~"
DCB :cat
plus_1:
DCB :plus_1+$2
  LDX #2
  JSR popDS
  LDX #0
  JSR popDS
  CLC
  LDA $02
  ADC $00
  STA $00
  LDA $03
  ADC $01
  STA $01
  JSR pushDS
  JMP next

minus:
DCB $01
DCB "-~~~~"
DCB :plus
minus_1:
DCB :minus_1+$2
  LDX #2
  JSR popDS
  LDX #0
  JSR popDS
  SEC
  LDA $00
  SBC $02
  STA $00
  LDA $01
  SBC $03
  STA $01
  JSR pushDS
  JMP next

twocomp:
DCB $5
DCB "2COMP"
DCB :minus
twocomp_1:
DCB :twocomp_1+$2
  LDX #0
  JSR popDS
  JSR _two_comp
  JSR pushDS
  JMP next

abs:
DCB $3
DCB "ABS~~"
DCB :twocomp
abs_1:
DCB :abs_1+$2
  LDY SP
  LDA DSTACK+1,Y
  BPL abs_end
  LDX #0
  JSR popDS
  JSR _two_comp
  JSR pushDS
abs_end:
  JMP next

eq:
DCB $1
DCB "=~~~~"
DCB :abs
eq_1:
DCB :eq_1+$2
  JSR stack_cmp
  BNE cmp_f
  BEQ cmp_t

lt:
DCB $1
DCB "<~~~~"
DCB :eq
lt_1:
DCB :lt_1+$2
  JSR stack_cmp
  BCS cmp_f
  BCC cmp_t

gt:
DCB $1
DCB ">~~~~"
DCB :lt
gt_1:
DCB :gt_1+$2
  JSR stack_cmp
  BCC cmp_f
  BEQ cmp_f
  BCS cmp_t

lte:
DCB $2
DCB "<=~~~"
DCB :gt
lte_1:
DCB :lte_1+$2
  JSR stack_cmp
  BCC cmp_t
  BEQ cmp_t
  BCS cmp_f


;Used by all comparisons
cmp_f:
  LDA #0
  JSR pushByte
  JMP next
cmp_t:
  LDA #1
  JSR pushByte
  JMP next


gte:
DCB $2
DCB ">=~~~"
DCB :lte
gte_1:
DCB :gte_1+$2
  JSR stack_cmp
  BCC cmp_f
  BCS cmp_t

zero_eq:
DCB $2
DCB "0=~~~"
DCB :gte
zero_eq_1:
DCB :zero_eq_1+$2
  JSR zero_cmp
  BEQ cmp_t
  BNE cmp_f

zero_lt:
DCB $2
DCB "0<~~~"
DCB :zero_eq
zero_lt_1:
DCB :zero_lt_1+$2
  JSR zero_cmp
  BCC cmp_t
  BCS cmp_f

constant:
DCB $08
DCB "CONST"
DCB :zero_lt
constant_1:
DCB :colon
;TODO
DCB :semi
constant_scode:
  LDY #1
  LDA (WA),Y
  STA $01
  DEY
  LDA (WA),Y
  STA $00
  LDX #0
  JSR pushDS
  JMP next

variable:
DCB $08
DCB "VARIA"
DCB :constant
variable_1:
DCB :colon
;TODO
DCB :semi
variable_scode:
  LDX #WA
  JSR pushDS
  JMP next

;actually a variable, returns address into zero page
;Numeric base
base_var:
DCB $04
DCB "BASE~"
DCB :variable
base_var_1:
DCB :constant_scode 
  DCB BASE,$00

;actually a variable, returns address into zero page
;Does various things
mode_var:
DCB $04
DCB "MODE~"
DCB :base_var
mode_var_1:
DCB :constant_scode
  DCB MODE,$00

;actually a variable, returns address into zero page
context_var:
DCB $07
DCB "CONTE"
DCB :mode_var
context_var_1:
DCB :constant_scode
  DCB CONTEXT,$00

;actually a variable, returns address into zero page
current_var:
DCB $07
DCB "CURRE"
DCB :context_var
current_var_1:
DCB :constant_scode
  DCB CURRENT,$00


;pointer to the head of the compile dictionary
compiler_var:
DCB $8
DCB "COMPI"
DCB :current_var
compiler_var_1:
DCB :variable_scode
  DCB :0 ;placeholder, will be filled on startup

;actually a variable, returns address into zero page
sp_var:
DCB $02
DCB "SP~~~"
DCB :compiler_var
sp_var_1:
DCB :constant_scode
  DCB SP,$00

;actually a variable, returns address into zero page
rsp_var:
DCB $03
DCB "RSP~~"
DCB :sp_var
rsp_var_1:
DCB :constant_scode
  DCB RSP,$00

sp_base:
DCB $03
DCB "SPB~~"
DCB :rsp_var
sp_base_1:
DCB :constant_scode
  DCB :DSTACK

rsp_base:
DCB $04
DCB "RSPB~"
DCB :sp_base
rsp_base_1:
DCB :constant_scode
  DCB :RSTACK

dp_var:
DCB $02
DCB "DP~~~"
DCB :rsp_base
dp_var_1:
DCB :constant_scode
  DCB DP,$00

;Enclose a stack word in the dict
comma:
DCB $1
DCB ",~~~~"
DCB :dp_var
comma_1:
DCB :colon
  DCB :dpat_1
  DCB :dup_1    
  DCB :rrot_1          ;stack is daddr, word, daddr <
  DCB :bang_1          ;add it to dict
  DCB :_clitnum, 2
  DCB :plus_1
  DCB :dpbang_1          ;advance dp 2
  DCB :semi

;Enclose a stack byte in the dict
ccomma:
DCB 2
DCB "C,~~~"
DCB :comma
ccomma_1:
DCB :colon
  DCB :dpat_1
  DCB :dup_1    
  DCB :rrot_1          ;stack is daddr, word, daddr <
  DCB :cbang_1          ;add it to dict
  DCB :_clitnum, 1
  DCB :plus_1
  DCB :dpbang_1          ;advance dp 1
  DCB :semi

spat:
DCB $3
DCB "SP@~~"
DCB :ccomma
spat_1:
DCB :colon
  DCB :sp_base_1
  DCB :plus_1
  DCB :at_1
  DCB :semi

spbang:
DCB $3
DCB "SP!~~"
DCB :spat
spbang_1:
DCB :colon
  DCB :sp_base_1
  DCB :plus_1
  DCB :bang_1
  DCB :semi

dpat:
DCB $3
DCB "DP@~~"
DCB :spbang
dpat_1:
DCB :colon
  DCB :_litnum, :DP
  DCB :at_1
  DCB :semi

dpbang:
DCB $3
DCB "DP!~~"
DCB :dpat
dpbang_1:
DCB :colon
  DCB :_litnum, :DP
  DCB :bang_1
  DCB :semi

;CURRENT @
;last entry added's header
entry:
DCB 5
DCB "ENTRY"
DCB :dpbang
entry_1:
DCB :colon
  DCB :current_var_1
  DCB :at_1
  DCB :semi

;modifies last entry's (or curr entry's) CA
;sets to popstack
ca_bang:
DCB 3
DCB "CA!~~"
DCB :entry
ca_bang_1:
DCB :colon
  DCB :entry_1
  DCB :_clitnum, 8
  DCB :plus_1
  DCB :bang_1
  DCB :semi

;creates a header
;links it along
create:
DCB 6
DCB "CREAT"
DCB :ca_bang
create_1:
DCB :colon
  DCB :entry_1   ;store link to previous
  DCB :dpat_1    
  DCB :current_var_1
  DCB :bang_1    ;update current (stack is now entry)
  DCB :aspace_1  ;fetch a token
  DCB :token_1
  DCB :dpat_1
  DCB :_clitnum, 6
  DCB :plus_1
  DCB :dpbang_1  ;enclose in dictionary
  DCB :comma_1   ;enclose link
  DCB :dpat_1
  DCB :_clitnum, 2
  DCB :plus_1
  DCB :comma_1   ;enclose WA+2 as CA
  DCB :semi

wcolon:
DCB $1
DCB ":~~~~"
DCB :create
wcolon_1:
DCB :colon
  DCB :create_1          ;create a word
  DCB :_litnum, :colon   
  DCB :ca_bang_1          ;make it secondary
  DCB :mode_var_1        ;turn on compile mode
  DCB :cat_1
  DCB :_clitnum, $4      ;bit #3
  DCB :or_1
  DCB :mode_var_1
  DCB :cbang_1
  DCB :semi

;adds the last word to the compile vocabulary
immediate:
DCB $9
DCB "IMMED"
DCB :wcolon
immediate_1:
DCB :colon

decimal:
DCB $07
DCB "DECIM"
DCB :immediate
decimal_1:
DCB :decimal_1+$2
  LDA #$0a
  STA BASE
  JMP next

hex:
DCB $03
DCB "HEX~~"
DCB :decimal
hex_1:
DCB :hex_1+$2
  LDA #$10
  STA BASE
  JMP next

;When input fails to parse, 
;test if empty string or complain ('?')
;if failed jump to _patch
question:
DCB $08
DCB "QUEST"
DCB :hex
question_1:
DCB :question_1+$2
  LDX #0
  LDA (DP,X)
  BEQ question_ok
  TAY
  INY
  LDA #$20
  STA (DP),Y
  INY
  LDA #$3f
  STA (DP),Y
  TYA
  STA (DP,X)
  LDX #DP
  JSR pushDS
  JMP _patch+$2
  question_ok:
  LDA #<okmsg
  STA $00
  LDA #>okmsg
  STA $01
  LDX #0
  JSR pushDS
  JMP next

;Verify that the stack is intact
;If not, jump to _patch
qstack:
DCB $06
DCB "?STAC"
DCB :question
qstack_1:
DCB :colon
  DCB :_clitnum,MODE
  DCB :cat_1
  DCB :_clitnum,$02    ;check 2 bit (underflow)
  DCB :and_1           ;&
  DCB :_if,$07
  DCB :_litnum,:stackmsg
  DCB :_patch
  DCB :semi

;parse number
;if in compile mode, enclose with handler
;also push 0 on success, 1 on failure
qnumber:
DCB $07
DCB "?NUMB"
DCB :qstack
qnumber_1:
DCB :colon
  DCB :number_1                    ;try parsing number
  DCB :_if,$24                     ;if(number success) {
    DCB :_compile_p                ;  if(compiling)
    DCB :_if,$19                   ;  {
      DCB :single_1                ;    if(single)
      DCB :_if,$c                  ;    {
        DCB :_litnum, :_clitnum    ;      singlehandler
        DCB :comma_1               ;      enclose singlehandler
        DCB :ccomma_1              ;      enclose number
      DCB :_else,$9                ;    } else {
        DCB :_litnum, :_litnum     ;      wordhandler
        DCB :comma_1               ;      enclose handler
        DCB :comma_1               ;      enclose number
                                   ;    }
    DCB :_clitnum, 0               ;  } push(0) //success
  DCB :_else,$4                    ;} else {
    DCB :_clitnum, 1               ;  push(1) //failure
  DCB :semi                        ;}


;parses a text number into a stack number
;returns number, 1< if success
;0< on fail
;$00,$01 is result
;$02,$03 is used by multiply
;$4 is multiplier
;$05 is numdigits
number:
DCB $06
DCB "NUMBE"
DCB :qnumber
number_1:
DCB :number_1+$2
  LDY #0
  STY $00
  STY $01
  LDA (DP),Y
  BEQ number_fail
  STA $05
  INY
  LDA (DP),Y
  CMP #$2d           ;if starts with "-", skip it
  BNE number_fetch_1
  LDA $05
  CMP #$2
  BMI number_fail
number_fetch_loop:
  INY
  LDA (DP),Y
number_fetch_1:         ;conver char to value
  SEC
  SBC #$30            ;#$30 - #$3a is 0-9
  BMI number_fail
  CMP #$a
  BMI number_skip_ascii
  SBC #$07            ;shift to letters
  CMP #$0a            ;if <A fail
  BMI number_fail
  CMP #$24            ;if >Z fail
  BPL number_fail
number_skip_ascii:     
  CMP BASE
  BPL number_fail
  ADC $00            ;add to existing number (carry happens in multiply)
  STA $00
  BCC number_skip_add_carry
  INC $01
number_skip_add_carry:
  TYA
  CMP $05            ;check string end
  BEQ number_end
  LDA BASE           
  STA $04            ;shift number left by BASE
  JSR multiply
  JMP number_fetch_loop
number_fail:           ;if fails push a 0
  LDX #0
  STX $00
  STX $01
  JSR pushDS
  JMP next
number_end:
  LDX #0
  LDY #1
  LDA (DP),Y
  CMP #$2d          ;"-"
  BNE number_end_2
  JSR _two_comp     ;make negative if necessary
number_end_2:
  JSR pushDS        ;push the number then a 1
  INX
  STX $00
  DEX
  STX $01
  JSR pushDS
  JMP next

;pushes 1 if top stack is single-byte
;pushes 0 otherwise
;doesnt pop stack
single:
DCB $06
DCB "SINGL"
DCB :number
single_1:
DCB :single_1+$2
  LDX #0
  STX $00
  STX $01 ;prepare pushing value
  LDY SP
  LDA DSTACK+1,Y   ;get stack(1) hi-byte
  BNE single_2
  LDA #1 
  STA $00          ;if hibyte is 0 then push 1
single_2:
  JSR pushDS
  JMP next

break:
DCB $03
DCB "BRK~~"
DCB :single
break_1:
DCB :break_1+$2
  BRK
  JMP next

;prints out the stack nondestructively
dots:
DCB $02
DCB ".S~~~"
DCB :break
dots_1:
DCB :colon
  DCB :sp_var_1
  DCB :cat_1                         
  DCB :_clitnum, $2, :plus_1         ;get next address on stack
  DCB :dup_1, :_clitnum, $ff, :lt_1  ;if past top of stack
  DCB :_if,$a                        ;skip while
  DCB :dup_1, :spat_1, :dot_1
  DCB :_while,$17                    ;-> dup_1,:clitnum...
  DCB :_clitnum, $2e                 ;"." 
  DCB :echo_1
  DCB :drop_1
  DCB :semi

;DUP .
ddot:
DCB $02
DCB "D.~~~"
DCB :dots
ddot_1:
DCB :colon
  DCB :dup_1
  DCB :dot_1
  DCB :semi

;prints out a number from the stack
dot:
DCB $01
DCB ".~~~~"
DCB :ddot
dot_1:
DCB :colon
  DCB :dup_1,:zero_lt_1
  DCB :r_left_1     ;put <0? on rstack
  DCB :abs_1
  DCB :_clitnum,$0  ;terminating null
  DCB :aspace_1
  DCB :lrot_1       ;stack is now 0 SPC NUM <
  DCB :digascii_1   ;pull out a digit
  DCB :dup_1        ;if remainder!=0
  DCB :_if,$04
  DCB :_while,$09   ;->digascii_1
  DCB :drop_1       ;else drop remainder
  DCB :r_right_1    ;if <0 print "-"
  DCB :_if,$4
  DCB :_clitnum, $2d   ;"-"
  DCB :display_1    ;display the result
  DCB :semi

;prints out an unsigned number from the stack
udot:
DCB $02
DCB "U.~~~"
DCB :dot
udot_1:
DCB :colon
  DCB :_clitnum,$0  ;terminating null
  DCB :aspace_1
  DCB :lrot_1       ;stack is now 0 SPC NUM <
  DCB :digascii_1   ;pull out a digit
  DCB :dup_1        ;if remainder!=0
  DCB :_if,$04
  DCB :_while,$09   ;->digascii_1
  DCB :drop_1       ;else drop remainder
  DCB :display_1    ;display the result
  DCB :semi

;prints out char codes from the stack
;until it hits a zero
display:
DCB $07
DCB "DISPL"
DCB :udot
display_1:
DCB :colon
  DCB :dup_1
  DCB :_if,$06 ;-> drop_1
  DCB :echo_1
  DCB :_while,$09 ;->dup_1
  DCB :drop_1
  DCB :semi

;takes a number on the stack
;pulls out a digit into ascii
;returns CHAR REMAINDER <
digascii:
DCB $08
DCB "DIGAS"
DCB :display
digascii_1:
DCB :colon
  DCB :_clitnum,BASE
  DCB :cat_1
  DCB :modslash_1
  DCB :ascii_1
  DCB :swap_1
  DCB :semi

;number -> its char code
ascii:
DCB $05
DCB "ASCII"
DCB :digascii
ascii_1:
DCB :ascii_1+$2
  LDX #0
  JSR popDS
  LDA $00
  CLC
  ADC #$37
  CMP #$41
  BPL ascii_end
  SBC #$6
ascii_end:
  STA $00
  JSR pushDS
  JMP next

;prints one char code from stack
echo:
DCB $04
DCB "ECHO~"
DCB :ascii
echo_1:
DCB :echo_1+$2
  LDX #0
  JSR popDS
  LDA $00
  JSR draw_char
  JSR cursor_fwd
  JMP next

clear:
DCB $5
DCB "CLEAR"
DCB :echo
clear_1:
DCB :clear_1+$2
  JSR clear_screen
  JSR reset_cursor
  JMP next

;searches the dictionary for last token entered
;searches vocab at top of stack
;leaves: WA 0<
;if failed: 1<
search:
DCB $06
DCB "SEARC"
DCB :clear
search_1:
DCB :search_1+$2
  LDX #0            ;pops vocab ptr 
  JSR popDS
  LDY #0
  LDA (DP),Y
  CMP #$5
  BMI search_2
  LDA #$5
search_2:
  STA $02
  JMP search_comp
search_walk_list:
  LDY #$6
  LDA ($00),Y
  PHA
  INY
  LDA ($00),Y
  STA $01
  PLA
  STA $00
search_comp:
  LDA $01
  BEQ search_term
  LDY $02
search_comp_loop:
  LDA (DP),Y
  CMP ($00),Y
  BNE search_walk_list
  DEY
  BPL search_comp_loop
  LDA $00
  CLC
  ADC #$08
  BCC search_skip_carry
  INC $01
search_skip_carry:
  STA $00
  LDX #0
  JSR pushDS       ;Push address
  LDX #0
  STX $00
  STX $01
  JSR pushDS       ;push 0 (success)
  JMP next
search_term:
  LDX #1
  STX $00          ;if failed push 1 (failure)
  DEX
  JSR pushDS
  JMP next

;pushes an ascii space
aspace:
DCB $06
DCB "ASPAC"
DCB :search
aspace_1:
DCB :aspace_1+$2
  LDX #0
  STX $01
  LDA #$20
  STA $00
  JSR pushDS
  JMP next

;pulls out the next token from the input text
;put into free dictionary space
token:
DCB $05
DCB "TOKEN"
DCB :aspace
token_1:
DCB :token_1+$2
  LDX #0
  JSR popDS
  LDA $00
  CMP #$20
  BNE token_space_skip
  LDX buff_pos
  DEX
token_space_loop:
  INX
  LDA buff,X
  CMP #$20
  BEQ token_space_loop
  STX buff_pos
token_space_skip:
  LDX buff_pos
  LDY #0
token_real_loop:
  INY
  LDA buff,X
  BEQ token_end
  INX
  JSR make_uppercase
  STA (DP),Y
  CMP $00
  BEQ token_end_2
  BNE token_real_loop
token_end:
  INX
token_end_2:
  STX buff_pos
  DEY
  TYA
  LDX #0
  STA (DP,X)
  JMP next

inline:
DCB $06
DCB "INLIN"
DCB :token
inline_1:
DCB :inline_1+$2
  JSR freshline
  LDA #59
  STA buff_size
  LDA #$3e
  JSR type_char
  JSR get_line
  LDA #0
  STA buff_pos
  JSR freshline
  JMP next

;takes a string ptr off the stack
;prints it out
type:
DCB $04
DCB "TYPE~"
DCB :inline
type_1:
DCB :type_1+$2
  LDX #P0L
  JSR popDS
  LDX #0
  LDA (P0L,X)
  INC P0L
  BCC type_2
  INC P0H
  type_2:
  JSR draw_string
  JMP next

start:
DCB $05
DCB "START"
DCB :type
DCB $ff
start_1:
DCB :start_1+$2
  forth_start:
  LDA MODE
  AND #1        ;check 1-bit
  BNE forth_restart
  JSR clear_screen
  JSR reset_cursor
  LDA #<startmsg
  STA WA
  LDA #>startmsg
  STA WA+1
  LDA #<dict_start
  STA DP
  LDA #>dict_start
  STA DP+1
  LDA #<last_dict
  STA CONTEXT
  STA CURRENT
  LDA #>last_dict
  STA CONTEXT+1
  STA CURRENT+1
  LDA #<last_compile
  STA compiler_var_1+2
  LDA #>last_compile
  STA compiler_var_1+3
forth_restart:
  LDA #1
  STA MODE     ;set 1 bit clear others
  LDA #$0A
  STA BASE
  LDA #0
  STA SP
  STA RSP
  STA buff_pos
  LDA #<outer_interp
  STA IR
  LDA #>outer_interp
  STA IR+1
  LDX #WA
  JSR pushDS
  JMP next


last_dict:
DCB $ff
DCB "NULL~"
DCB :start
DCB $ff,$ff


dict_start:


*=$de00
DSTACK:
*=$df00
RSTACK:
*=$df01
RSTACKH:


*=$fd00
;character data
keytable1:
DCB $00,$00,$00,$00,$00   ;   $20
DCB $00,$00,$fa,$00,$00   ;!  
DCB $a0,$c0,$00,$a0,$c0   ;"  
DCB $28,$7c,$28,$7c,$28   ;#  
DCB $20,$54,$fe,$54,$08   ;$  
DCB $48,$b0,$54,$1a,$24   ;%  
DCB $2c,$5a,$4a,$44,$0a   ;&  
DCB $00,$00,$a0,$c0,$00   ;'  
DCB $00,$38,$44,$82,$00   ;(  $28
DCB $00,$82,$44,$38,$00   ;)  
DCB $00,$50,$e0,$50,$00   ;*  
DCB $10,$10,$7c,$10,$10   ;+  
DCB $00,$00,$07,$06,$00   ;,  
DCB $10,$10,$10,$10,$10   ;-  
DCB $00,$00,$06,$06,$00   ;.  
DCB $06,$08,$10,$20,$c0   ;/  
DCB $7c,$8a,$92,$a2,$7c   ;0  $30
DCB $22,$42,$fe,$02,$02   ;1  
DCB $42,$86,$8a,$92,$62   ;2  
DCB $44,$92,$92,$92,$6c   ;3  
DCB $18,$28,$48,$fe,$08   ;4  
DCB $f2,$a2,$a2,$a2,$9c   ;5  
DCB $3c,$52,$92,$92,$8c   ;6  
DCB $86,$88,$90,$a0,$c0   ;7  
DCB $6c,$92,$92,$92,$6c   ;8  
DCB $64,$92,$92,$92,$7c   ;9  $39
DCB $00,$00,$66,$66,$00   ;:  
DCB $00,$00,$67,$66,$00   ;;  
DCB $10,$28,$28,$44,$44   ;<  
DCB $28,$28,$28,$28,$28   ;=  
DCB $44,$44,$28,$28,$10   ;>  
DCB $40,$80,$8a,$90,$60   ;?  
DCB $7c,$82,$9a,$aa,$78   ;@  
DCB $0e,$30,$d0,$30,$0e   ;A  $41
DCB $fe,$92,$92,$72,$0c   ;B  
DCB $38,$44,$82,$82,$44   ;C  
DCB $fe,$82,$82,$44,$38   ;D  
DCB $fe,$92,$92,$82,$82   ;E  
DCB $fe,$90,$90,$80,$80   ;F  
DCB $7c,$82,$82,$8a,$4e   ;G  
DCB $fe,$10,$10,$10,$fe   ;H  $48
DCB $82,$82,$fe,$82,$82   ;I  
DCB $82,$82,$fc,$80,$80   ;J  
DCB $fe,$10,$30,$48,$86   ;K  
DCB $fe,$02,$02,$02,$02   ;L  
DCB $fe,$30,$08,$30,$fe   ;M  
DCB $fe,$20,$10,$08,$fe   ;N  
DCB $7c,$82,$82,$82,$7c   ;O  
DCB $fe,$90,$90,$90,$60   ;P  $50
DCB $7c,$82,$8a,$84,$7a   ;Q  
*=$fe00
keytable2:
DCB $fe,$90,$98,$94,$62   ;R  $52
DCB $62,$92,$92,$92,$8c   ;S
DCB $80,$80,$fe,$80,$80   ;T
DCB $fc,$02,$02,$02,$fc   ;U
DCB $e0,$18,$06,$18,$e0   ;V
DCB $f0,$0e,$30,$0e,$f0   ;W
DCB $c6,$28,$10,$28,$c6   ;X  $58
DCB $c0,$20,$1e,$20,$c0   ;Y
DCB $86,$8a,$92,$a2,$c2   ;Z
DCB $00,$fe,$82,$82,$00   ;[
DCB $c0,$20,$10,$08,$06   ;\
DCB $00,$82,$82,$fe,$00   ;]
DCB $20,$40,$80,$40,$20   ;^
DCB $02,$02,$02,$02,$02   ;_
DCB $00,$00,$80,$40,$00   ;`  $60
DCB $04,$2a,$2a,$1c,$02   ;a
DCB $fe,$24,$22,$22,$1c   ;b
DCB $1c,$22,$22,$22,$14   ;c
DCB $1c,$22,$22,$24,$fe   ;d
DCB $1c,$2a,$2a,$2a,$1a   ;e
DCB $20,$20,$7e,$a0,$a0   ;f
DCB $19,$25,$25,$15,$3e   ;g
DCB $fe,$10,$20,$20,$1e   ;h  $68
DCB $02,$22,$be,$02,$02   ;i
DCB $00,$22,$22,$22,$bc   ;j
DCB $fe,$04,$08,$14,$22   ;k
DCB $02,$82,$fe,$02,$02   ;l
DCB $3e,$20,$1e,$20,$1e   ;m
DCB $3e,$10,$20,$20,$1e   ;n
DCB $1c,$22,$22,$22,$1c   ;o
DCB $3f,$14,$22,$22,$1c   ;p  $70
DCB $1c,$22,$22,$14,$3f   ;q
DCB $3e,$10,$20,$20,$10   ;r
DCB $12,$2a,$2a,$2a,$24   ;s
DCB $20,$20,$7c,$22,$22   ;t
DCB $3c,$02,$02,$04,$3e   ;u
DCB $38,$04,$02,$04,$38   ;v
DCB $3c,$02,$3c,$02,$3c   ;w
DCB $22,$14,$08,$14,$22   ;x  $78
DCB $32,$0a,$04,$08,$30   ;y
DCB $22,$26,$2a,$32,$22   ;z
DCB $10,$10,$6c,$82,$82   ;{
DCB $00,$00,$fe,$00,$00   ;|
DCB $82,$82,$6c,$10,$10   ;}
DCB $10,$20,$10,$08,$10   ;~  $7e
DCB $ff,$ff,$ff,$ff,$ff   ;
